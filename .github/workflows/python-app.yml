#This will take the .net files and place the values of the correlations at the
# correct location according to the new ordering
def build_Matrix(parcellation, net_file, fisherz=False, unordered=False):

    #open the input file
    with open(net_file.filename) as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=' ')
        skip_line = net_file.num_of_header_lines
        line_count = 0
        #Create a Zero matix the size of num of parcels x num of parcels
        a = np.zeros((parcellation.num_of_parcels, parcellation.num_of_parcels))
        for row in csv_reader:
            #Skip the headers
            if line_count < skip_line:
                line_count += 1
            else:
                if not unordered:
                    a[parcellation.new_order.index(int(row[0]) - 1), parcellation.new_order.index(
                        int(row[1]) - 1)] = float(row[2])
                else:
                    a[int(row[0]) - 1, int(row[1]) - 1] = float(row[2])
                line_count += 1


    a = (a + a.T)


    if fisherz:

        a = np.arctanh(a)
        max = np.amax(a)
        min = np.amin(a)
        np.fill_diagonal(a, np.inf)

    else:
        max = np.amax(a)
        min = np.amin(a)
        np.fill_diagonal(a, 1.)
    a = a.round(5)
    return a, max, min


def write_new_order(new_order,outfile):
    print("Writing the new ordering to file: " + outfile)
    with open(outfile, 'w') as f:
        for item in new_order:
            f.write("%s\n" % item)


#Plot the matrix to a corr matrix
def plot_correlation_matrix(parcellation, subject, output_file, matrix, max, min, fisherz=False):

    #Place in a data frame
    df = pd.DataFrame(matrix)
    plt.matshow(df)

    #Create the Title
    if fisherz:
        plt.title(str(subject) + ' ' + parcellation.parcellation + ' fisher-z')
    else:
        plt.title(str(subject) + ' ' + parcellation.parcellation)
    if abs(min) > abs(max):
        max = min * -1
    else:
        min = max * -1

    plt.imshow(df, vmin=min, vmax=max)

    #Setup the boundaries for the network
    for i in range(len(parcellation.length_list) - 1):
        plt.axhline(y=parcellation.length_list[i], color='black', linestyle='-')
        plt.axvline(x=parcellation.length_list[i], color='black', linestyle='-')
    names = list(parcellation.network_dict.keys())

    #set the tick location to be in the middle of the network boundaries
    tick_location = []
    tick_location.append((parcellation.length_list[0]) / 2)
    for i in range(1, len(parcellation.length_list)):
        tick_location.append(parcellation.length_list[i - 1] + ((parcellation.length_list[i] -
                                                                parcellation.length_list[i - 1]) / 2))

    #make the xticks slant
    plt.xticks(tick_location, names, rotation=45, horizontalalignment='right')
    ax = plt.gca()
    ax.tick_params(axis="x", direction="out", top=0, bottom=1, labelbottom=1, labeltop=0)
    plt.yticks(tick_location, names)

    plt.colorbar()
    plt.set_cmap('seismic')
    plt.savefig(output_file,bbox_inches='tight',pad_inches=.25, dpi=400)


#write the matrix to a csv
def write_out_correlation(matrix, out_file):
    print("Writing out matix: " + out_file)
    np.set_printoptions(suppress=True, formatter={'float_kind':'{:16.3f}'.format}, linewidth=130)
    np.savetxt(out_file, matrix, '%5.5f', delimiter=",")


#Check to see if we have setup that parcellation scheme
def check_input(net_file):
    if net_file.parcellation == 'aal116':
        print("Sorry " + net_file.parcellation + " has not yet been implemented")
        exit()
    elif net_file.parcellation == 'glasser360':
        print("Sorry " + net_file.parcellation + " has not yet been implemented")
        exit()
    elif net_file.parcellation == 'gordon333':
        print("Sorry " + net_file.parcellation + " has not yet been implemented")
        exit()
    elif net_file.parcellation == 'power264':
        print("Using " + net_file.parcellation)
        parcellation = Power264
    elif net_file.parcellation == 'schaefer100':
        print("Sorry " + net_file.parcellation + " has not yet been implemented")
        exit()
    elif net_file.parcellation == 'schaefer200':
        print("Sorry " + net_file.parcellation + " has not yet been implemented")
        exit()
    elif net_file.parcellation == 'schaefer400' or net_file.parcellation == 'schaefer400x7':
        print("Using " + net_file.parcellation)
        parcellation = Schaefer400
    elif net_file.parcellation == 'schaefer400x17':
        print(f"Using {net_file.parcellation}")
        parcellation = Schaefer400x17
    else:
        print("Could not recognize parcellation: " + net_file.parcellation)
        exit()

    return parcellation


#Encapsulates all the processing
def run(net_file, parcellation, outputDir, fisherz, scaleBounds, outputUnordered, outputNewOrder):
    matrix, max, min = build_Matrix(parcellation=parcellation, net_file=net_file,
                                                  fisherz=fisherz, unordered=outputUnordered)
    if (scaleBounds):
        max = float(scaleBounds)
        min = -1 * max

    filename = net_file.subject + '_' + net_file.parcellation

    if fisherz:
        filename = filename + '_fisherz'
    if outputUnordered:
        filename = filename + '_unordered'

    output_file = os.path.join(outputDir, filename + '.csv')
    write_out_correlation(matrix=matrix, out_file=output_file)

    if not outputUnordered:
        output_file = os.path.join(outputDir, filename + '.png')
        plot_correlation_matrix(parcellation=parcellation, output_file=output_file, subject=net_file.subject,
                                          matrix=matrix, max=max, min=min, fisherz=fisherz)
    if outputNewOrder:
        write_new_order(parcellation.new_order, os.path.join(outputDir, net_file.parcellation + '_reordering'))


# This workflow will install Python dependencies, run tests and lint with a single version of Python
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions

name: Python application

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up Python 3.8
      uses: actions/setup-python@v2
      with:
        python-version: 3.8
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 pytest
        if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
    - name: Lint with flake8
      run: |
        # stop the build if there are Python syntax errors or undefined names
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
    - name: Test with pytest
      run: |
        pytest
